package server

import (
	"context"
	"net/http"
	"sync"

	"github.com/benchttp/engine/runner"
)

func ListenAndServe(addr string) error {
	return http.ListenAndServe(addr, &server{})
}

type server struct {
	mu               sync.RWMutex
	currentRequester *runner.Requester
	stopRun          context.CancelFunc
}

func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.URL.Path {
	case "/run":
		s.handleRun(w, r)
	case "/state":
		s.handleState(w, r)
	case "/stop":
		s.handleStop(w, r)
	default:
		http.NotFound(w, r)
	}
}

func (s *server) doRun(cfg runner.ConfigGlobal) (runner.OutputReport, error) {
	// Retrieve HTTP request generated by the config
	httpRequest, err := cfg.Request.Value()
	if err != nil {
		return runner.OutputReport{}, err
	}

	ctx, cancel := context.WithCancel(context.Background())
	s.setCurrentRequester(runner.NewRequester(requesterConfig(cfg)))
	s.setStopRun(cancel)

	// Run benchmark
	bk, err := s.currentRequester.Run(ctx, httpRequest)
	if err != nil {
		return runner.OutputReport{}, err
	}

	return *runner.NewOutput(bk, cfg), nil
}

func (s *server) setCurrentRequester(r *runner.Requester) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.currentRequester = r
}

func (s *server) setStopRun(cancelFunc context.CancelFunc) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.stopRun = cancelFunc
}

func (s *server) flush() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.currentRequester = nil
	s.stopRun = nil
}

func (s *server) isRequesterRunning() bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.currentRequester != nil
}

func (s *server) requesterState() (state runner.RequesterState, ok bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if s.currentRequester == nil {
		return runner.RequesterState{}, false
	}
	return s.currentRequester.State(), true
}

func (s *server) stopRequester() bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.currentRequester == nil {
		return false
	}
	s.stopRun()
	return true
}

// requesterConfig returns a runner.RequesterConfig generated from cfg.
func requesterConfig(cfg runner.ConfigGlobal) runner.RequesterConfig {
	return runner.RequesterConfig{
		Requests:       cfg.Runner.Requests,
		Concurrency:    cfg.Runner.Concurrency,
		Interval:       cfg.Runner.Interval,
		RequestTimeout: cfg.Runner.RequestTimeout,
		GlobalTimeout:  cfg.Runner.GlobalTimeout,
	}
}
